# -*- coding: utf-8 -*-
"""빅콘테스트.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1La9-tWVJmWhlW1McTMQ3PqJS_fNH6h58
"""

# 구글 드라이브 연결
from google.colab import drive
drive.mount('/content/drive')

import pandas as pd
import numpy as np

# 1. 본인의 구글 드라이브 경로
base_path = '/content/drive/MyDrive/bigcontest/'

# 2. 파일 경로 설정

file_info = base_path + 'big_data_set1_f.csv'
file_monthly = base_path + 'big_data_set2_f.csv'
file_customer = base_path + 'big_data_set3_f.csv'
file_map = base_path + 'map.csv'
df_map = pd.read_csv(file_map)

# 3. 데이터 로드 (encoding='cp949' 추가)
try:
    df_info = pd.read_csv(file_info, encoding='cp949')
    df_monthly = pd.read_csv(file_monthly, encoding='cp949')
    df_customer = pd.read_csv(file_customer, encoding='cp949')

    print("--- 🚀 데이터 로드 성공! (cp949 인코딩) ---")
    print("\n[데이터셋 1: 가맹점 정보 (df_info)]")
    print(df_info.head())

    print("\n[데이터셋 2: 월별 이용 정보 (df_monthly)]")
    print(df_monthly.head())

    print("\n[데이터셋 3: 월별 고객 정보 (df_customer)]")
    print(df_customer.head())

except FileNotFoundError:
    print(f"!!! ❌ 에러: 파일을 찾을 수 없습니다.")
    print(f"경로를 확인하세요. 혹시 'base_path'가 정확한가요?")
    print(f"입력된 경로: {base_path}")
except UnicodeDecodeError:
    print(f"!!! ❌ 에러: 'cp949'로도 해결되지 않았습니다.")
    print(f"다른 인코딩('euc-kr')을 시도해볼 수 있습니다.")
except Exception as e:
    print(f"!!! ❌ 에러 발생: {e}")

# 한글폰트 설치
!sudo apt-get install -y fonts-nanum
!sudo fc-cache -fv
!rm ~/.cache/matplotlib -rf

print("--- 폰트 설치 완료 ---")

# 데이터 전처리
import matplotlib.pyplot as plt
import seaborn as sns

# 특수값(SV)을 NaN으로 변환
df_monthly.replace(-999999.9, np.nan, inplace=True)
df_customer.replace(-999999.9, np.nan, inplace=True)

print("--- [df_customer] 특수값 처리 후 head() ---")
print(df_customer.head())
print("\n처리가 완료되었습니다. df_customer의 -999999.9 값이 NaN으로 변경되었습니다.")

"""## 1번 질문
{카페업종 가맹점} 카페의 주요 방문 고객 특성에 따른 마케팅 채널 추천 및 홍보안을 작성
"""

# 카페 업종 찾기
# 1. df_info (가맹점 개요)에서 업종 컬럼('HPSN_MCT_ZCD_NM')의 고유값 확인
industry_names = df_info['HPSN_MCT_ZCD_NM'].unique()

print(f"--- [총 {len(industry_names)}개의 고유 업종명 발견] ---")
# 너무 많을 수 있으니 상위 50개만 출력
print(industry_names[:50])

# 2. '카페' 또는 '커피'가 포함된 업종명 찾기
cafe_related_names = [name for name in industry_names if '카페' in name or '커피' in name]
print(f"\n--- [카페/커피 관련 업종명] ---")
print(cafe_related_names)

# 1. 'HPSN_MCT_ZCD_NM'(업종명) 컬럼에서 '카페' 또는 '커피'가 포함된 업종 찾기
cafe_industry_names = df_info[
    df_info['HPSN_MCT_ZCD_NM'].str.contains('카페|커피', na=False)
]['HPSN_MCT_ZCD_NM'].unique()

print(f"--- [카페/커피 관련 업종명] ---")
print(cafe_industry_names)

# 2. 해당 업종의 가맹점 정보만 필터링
cafe_info_df = df_info[
    df_info['HPSN_MCT_ZCD_NM'].isin(cafe_industry_names)
].copy()

# 3. 챗봇에게 필요한 최소 정보만 선택
# (MCT_NM은 가맹점명, HPSN_MCT_ZCD_NM은 업종명입니다)
cafe_info_df = cafe_info_df[['ENCODED_MCT', 'MCT_NM', 'HPSN_MCT_ZCD_NM']]
print(f"\n총 {len(cafe_info_df)}개의 카페 가맹점 정보를 추출했습니다.")
print(cafe_info_df.head())

# 1. 분석할 고객 특성 컬럼들을 리스트로 정의
age_gender_cols = [
    'M12_MAL_1020_RAT', 'M12_MAL_30_RAT', 'M12_MAL_40_RAT',
    'M12_MAL_50_RAT', 'M12_MAL_60_RAT', 'M12_FME_1020_RAT',
    'M12_FME_30_RAT', 'M12_FME_40_RAT', 'M12_FME_50_RAT', 'M12_FME_60_RAT'
]

visit_purpose_cols = [
    'RC_M1_SHC_RSD_UE_CLN_RAT', # 거주
    'RC_M1_SHC_WP_UE_CLN_RAT',  # 직장
    'RC_M1_SHC_FLP_UE_CLN_RAT'  # 유동
]

visit_type_cols = [
    'MCT_UE_CLN_REU_RAT', # 재방문
    'MCT_UE_CLN_NEW_RAT'  # 신규
]

# 2. '카페' 가맹점의 고객 데이터만 필터링
cafe_mct_list = cafe_info_df['ENCODED_MCT'].unique()
cafe_customer_df = df_customer[
    df_customer['ENCODED_MCT'].isin(cafe_mct_list)
]

# 3. 가맹점 ID별로 그룹화하여 평균 프로필 계산
profile_cols = age_gender_cols + visit_purpose_cols + visit_type_cols
cafe_profile_df = cafe_customer_df.groupby('ENCODED_MCT')[profile_cols].mean()

# 인덱스를 컬럼으로 재설정
cafe_profile_df = cafe_profile_df.reset_index()

print("\n--- [가맹점별 평균 고객 프로필 생성 완료] ---")
print(cafe_profile_df.head())

# 1. 가맹점 정보(이름)와 고객 프로필(평균값)을 'ENCODED_MCT' 기준으로 병합
final_cafe_profiles_df = pd.merge(
    cafe_info_df,
    cafe_profile_df,
    on='ENCODED_MCT'
)

# 2. 업종 통합: final_cafe_profiles_df에 df_map을 병합하여 'map' 컬럼 생성
final_cafe_profiles_df = pd.merge(
    final_cafe_profiles_df,
    df_map[['HPSN_MCT_ZCD_NM', 'map']], # df_map에서 필요한 컬럼만 선택
    on='HPSN_MCT_ZCD_NM',
    how='left'
)

print("\n--- [최종 '카페 프로필' 데이터셋 완성] ---")
print(final_cafe_profiles_df.head())

# 2. 챗봇이 로드할 수 있도록 이 파일을 CSV로 저장
output_path = base_path + 'analysis_cafe_profiles.csv'
final_cafe_profiles_df.to_csv(output_path, index=False, encoding='utf-8-sig')

print(f"\n파일이 '{output_path}' 경로에 저장되었습니다.")


# 3. 결과 확인 (선택 사항)
print("\n--- [업종 'map' 컬럼 추가 완료] ---")
print(final_cafe_profiles_df.head())

# 4. 챗봇이 로드할 수 있도록 이 파일을 CSV로 저장
# (가정: base_path와 최종 df가 정의되어 있다고 가정)
output_path = base_path + 'analysis_cafe_profiles.csv'
final_cafe_profiles_df.to_csv(output_path, index=False, encoding='utf-8-sig')

print(f"\n파일이 '{output_path}' 경로에 저장되었습니다.")

"""##2번 질문
{재방문률 30% 미만 가맹점}의 타겟 고객과 마케팅 주력 시기를 선정하여 개선 방안 제시
"""

# 업종 분류 (중복업종 통합)
file_map = base_path + 'map.csv'
df_map = pd.read_csv(file_map)

# 고객특성 별 컬럼 생성
PER_COLS = ['M12_MAL_1020_RAT', 'M12_MAL_30_RAT', 'M12_MAL_40_RAT', 'M12_MAL_50_RAT', 'M12_MAL_60_RAT',
            'M12_FME_1020_RAT', 'M12_FME_30_RAT', 'M12_FME_40_RAT', 'M12_FME_50_RAT', 'M12_FME_60_RAT']
LABELS = ['1020남', '30남', '40남', '50남', '60남', '1020여', '30여', '40여', '50여', '60여']
BIG_LABELS = dict(zip(PER_COLS, LABELS))

PER_COLS2 = ['MCT_UE_CLN_NEW_RAT', 'RC_M1_SHC_RSD_UE_CLN_RAT',
             'RC_M1_SHC_WP_UE_CLN_RAT', 'RC_M1_SHC_FLP_UE_CLN_RAT']
LABELS2 = ['신규고객','거주고객', '직장고객', '유동고객']
BIG_LABELS2 = dict(zip(PER_COLS2, LABELS2))

# 업종 통합: df_info에 df_map을 병합하여 'map' 컬럼 생성
df_info_merged = pd.merge(df_info, df_map, on='HPSN_MCT_ZCD_NM', how='left')

# 월별 데이터 병합
df_data_monthly = pd.merge(df_monthly, df_customer, on=['ENCODED_MCT','TA_YM'], how='outer')

# 최종 병합
big_df = pd.merge(df_info_merged, df_data_monthly, on='ENCODED_MCT', how='left')

# TA_YM 날짜 포맷으로 변경 및 month 컬럼 생성
big_df['TA_YM'] = big_df['TA_YM'].astype(str).str[:4] + '-' + big_df['TA_YM'].astype(str).str[4:]
big_df['month'] = big_df['TA_YM'].str[-2:].astype(int)

# 업종 통합
industry_re_rate_avg = big_df.groupby('map')['MCT_UE_CLN_REU_RAT'].mean().to_dict()

print("--- 재방문률 데이터 병합 완료 ---")
print(big_df[['MCT_NM', 'map', 'TA_YM', 'MCT_UE_CLN_REU_RAT'] + PER_COLS[:3]].head())

# 가맹점 프로필 데이터 추출

unique_mct_ids = big_df['ENCODED_MCT'].dropna().unique()
all_profiles = []

# 각 ENCODED_MCT 별로 프로필 취합
for mct_id in unique_mct_ids:
    mct_df = big_df[big_df['ENCODED_MCT'] == mct_id].copy()

    try:
        # 가맹점명 및 업종 추출
        mct_map = mct_df['map'].iloc[0]
        mct_name = mct_df['MCT_NM'].iloc[0]

        # 재방문률 분석
        avg_re_rate = mct_df['MCT_UE_CLN_REU_RAT'].mean()

        # 월별 최고/최저 분석
        monthly_avg = mct_df.groupby('month')['MCT_UE_CLN_REU_RAT'].mean()
        worst_month = int(monthly_avg.idxmin())
        best_month = int(monthly_avg.idxmax())
        worst_rate = monthly_avg.min()
        best_rate = monthly_avg.max()

        # 고객 특성 분석
        # 가맹점 재방문율이 30% 미만인 레코드만 필터링
        low_re_rate_df = mct_df[mct_df['MCT_UE_CLN_REU_RAT'] < 30.0].copy()

        # 필터링된 데이터가 비어있으면 전체 데이터를 분석 대상으로 사용
        target_df = low_re_rate_df if not low_re_rate_df.empty else mct_df

        # 분석 대상 데이터의 고객 비율 평균 계산
        per_mean = target_df[PER_COLS + PER_COLS2].mean(numeric_only=True).dropna()

        # PER_COLS (성별/연령대) - 가장 적은 비율(worst)을 타겟으로 추출
        valid_per = per_mean.filter(PER_COLS)
        # 30% 미만인 레코드에서 가장 적은 비율을 차지하는 세그먼트가 '공략 대상'
        worst_per_label = BIG_LABELS.get(valid_per.idxmin(), '정보 없음') if not valid_per.empty else '정보 없음'

        # PER_COLS2 (고객 유형) - 최고/최저 추출
        valid_per2 = per_mean.filter(PER_COLS2)
        best_per2_label = BIG_LABELS2.get(valid_per2.idxmax(), '정보 없음') if not valid_per2.empty else '정보 없음'
        worst_per2_label = BIG_LABELS2.get(valid_per2.idxmin(), '정보 없음') if not valid_per2.empty else '정보 없음'

        # 재방문률 30% 미만 여부 진단
        # 업종 평균 재방문률 조회
        industry_avg = industry_re_rate_avg.get(mct_map, np.nan)

        # 가맹점/업종 재방문률 30% 미만 여부
        is_low_mct_re_rate = avg_re_rate < 30.0
        is_low_industry_re_rate = industry_avg < 30.0 if not np.isnan(industry_avg) else False

        # 4. 최종 프로필 데이터 딕셔너리 생성
        profile_data = {
            "mct_id": mct_id,
            "mct_name": mct_name,
            "map": mct_map,
            "avg_re_rate": avg_re_rate,
            "is_low_mct_re_rate": is_low_mct_re_rate,
            "industry_avg_re_rate": industry_avg,
            "is_low_industry_re_rate": is_low_industry_re_rate,
            "worst_month": worst_month,
            "worst_rate": worst_rate,
            "best_month": best_month,
            "target_per_segment": worst_per_label,
            "best_per_type": best_per2_label,
            "worst_per_type": worst_per2_label,
        }
        all_profiles.append(profile_data)

    except Exception as e:
        continue

print(f"분석 완료. 총 {len(all_profiles)}개의 가맹점 프로필 데이터 취합.")

# 취합된 리스트를 데이터프레임으로 변환
under_30per_re_rate = pd.DataFrame(all_profiles)

print(under_30per_re_rate[['mct_id', 'mct_name', 'map', 'avg_re_rate', 'is_low_mct_re_rate', 'is_low_industry_re_rate', 'target_per_segment']].head())

# 챗봇이 로드할 수 있도록 CSV로 저장
output_path = base_path + 'under_30per_re_rate.csv'
under_30per_re_rate.to_csv(output_path, index=False, encoding='utf-8-sig')

print(f"\n파일이 '{output_path}' 경로에 저장되었습니다.")

"""## 3번 질문
{요식업종 가맹점} 매장의 현재 가장 큰 문제점 및 이를 보완할 마케팅 아이디어와 근거를 제시
"""

# 구간 데이터를 숫자 점수로 변환
# (예: "1_10%이하" -> 1.0, "6_90%초과(하위 10% 이하)" -> 6.0)
rank_cols = ['MCT_OPE_MS_CN', 'RC_M1_SAA', 'RC_M1_TO_UE_CT', 'RC_M1_UE_CUS_CN', 'RC_M1_AV_NP_AT', 'APV_CE_RAT']

for col in rank_cols:
    df_monthly[f'{col}_score'] = df_monthly[col].str[0].astype(float)

print("\n--- 'df_monthly'에 숫자 스코어 컬럼 추가 완료 ---")
print(df_monthly[['RC_M1_SAA', 'RC_M1_SAA_score']].head())

# --- 1. ① 최신 월 정보 (P2, P3 진단용) ---
# TA_YM(기준년월)을 기준으로 내림차순 정렬 후, 가맹점별 첫 번째(가장 최신) 데이터만 남김
df_recent = df_monthly.sort_values('TA_YM', ascending=False).drop_duplicates('ENCODED_MCT')
print(f"가맹점별 '최신 월' 정보 생성 완료 (총 {len(df_recent)}건)")

# --- 2. ② 과거 통계 (P1 진단용) ---
# 가맹점별로 P1 진단에 필요한 '매출'과 '고객 수' 스코어의 평균(mean)과 표준편차(std) 계산
score_cols = ['RC_M1_SAA_score', 'RC_M1_UE_CUS_CN_score']
df_stats = df_monthly.groupby('ENCODED_MCT')[score_cols].agg(['mean', 'std'])
df_stats.columns = ['_'.join(col) for col in df_stats.columns.values] # 컬럼명 병합
print("가맹점별 '과거 통계' (평균, 표준편차) 생성 완료")

# --- 3. ③ 고객 프로필 (P4 진단용) ---
# (1번 질문에서 '카페'만 대상으로 했던 것을 '전체' 가맹점으로 확대)
customer_cols = [col for col in df_customer.columns if 'RAT' in col]
df_customer_profile = df_customer.groupby('ENCODED_MCT')[customer_cols].mean()
print("가맹점별 '평균 고객 프로필' 생성 완료")

# 1. df_info와 df_recent 병합
df_analysis = pd.merge(df_info[['ENCODED_MCT', 'MCT_NM', 'HPSN_MCT_ZCD_NM']],
                       df_recent,
                       on='ENCODED_MCT',
                       how='left') # 모든 가맹점 정보를 기준으로

# 2. df_stats 병합
df_analysis = pd.merge(df_analysis, df_stats, on='ENCODED_MCT', how='left')

# 3. df_customer_profile 병합
df_analysis = pd.merge(df_analysis, df_customer_profile, on='ENCODED_MCT', how='left')

print("\n--- '마스터 진단 파일' 병합 완료 ---")
print(f"최종 진단 대상 가맹점 수: {len(df_analysis)}")
print(df_analysis.head())

# --- [P1] 1순위: 시계열 급락 (Z-score) 진단 ---
# (최신 스코어 - 평균) / 표준편차. (스코어는 높을수록 나쁨)
z_sales = (df_analysis['RC_M1_SAA_score'] - df_analysis['RC_M1_SAA_score_mean']) / df_analysis['RC_M1_SAA_score_std']
z_customer = (df_analysis['RC_M1_UE_CUS_CN_score'] - df_analysis['RC_M1_UE_CUS_CN_score_mean']) / df_analysis['RC_M1_UE_CUS_CN_score_std']

# Z-score가 1.5 (평소보다 1.5 표준편차 이상 나빠짐) 이상인 경우
df_analysis['P1_Problem'] = (z_sales > 1.5) | (z_customer > 1.5)
df_analysis['P1_Details'] = np.where(z_sales > 1.5, f"매출 급락(Z-score:{z_sales.round(2)})", "") + \
                          np.where(z_customer > 1.5, f"고객 급감(Z-score:{z_customer.round(2)})", "")

# --- [P2] 2순위: 4분면 매트릭스 진단 ---
# (스코어는 1~6점, 3.5가 중앙값)
acq_score = (df_analysis['RC_M1_TO_UE_CT_score'] + df_analysis['RC_M1_UE_CUS_CN_score']) / 2
profit_score = (df_analysis['RC_M1_SAA_score'] + df_analysis['RC_M1_AV_NP_AT_score']) / 2

# 기준 설정 (High=좋음(<=3.0), Low=나쁨(>=4.0), Avg=애매(3.0~4.0))
cond_acq_high = (acq_score <= 3.0)
cond_acq_low = (acq_score >= 4.0)
cond_profit_high = (profit_score <= 3.0)
cond_profit_low = (profit_score >= 4.0)

# 유형 분류
cond_list = [
    (cond_acq_high & cond_profit_high), # P2_스타매장
    (cond_acq_low & cond_profit_high),  # P2_숨은맛집 (문제)
    (cond_acq_high & cond_profit_low),  # P2_박리다매 (문제)
    (cond_acq_low & cond_profit_low)    # P2_위기매장 (문제)
]
choice_list = ['P2_스타매장', 'P2_숨은맛집', 'P2_박리다매', 'P2_위기매장']
df_analysis['P2_Quadrant'] = np.select(cond_list, choice_list, default='P2_애매함')

# --- [P3] 3순위: 취소율 진단 ---
# 배달 유무 확인 (DLV_SAA_RAT이 NaN이 아니면 배달 매장)
cond_delivery = df_analysis['DLV_SAA_RAT'].notna()
cond_no_delivery = df_analysis['DLV_SAA_RAT'].isna()

# 기준 적용 (배달: 5~6구간, 홀: 3~6구간일 때 문제)
cond_delivery_high_cancel = (cond_delivery & (df_analysis['APV_CE_RAT_score'] >= 5.0))
cond_no_delivery_high_cancel = (cond_no_delivery & (df_analysis['APV_CE_RAT_score'] >= 3.0))

df_analysis['P3_Problem'] = cond_delivery_high_cancel | cond_no_delivery_high_cancel
df_analysis['P3_Details'] = np.where(df_analysis['P3_Problem'], f"취소율 높음(구간:{df_analysis['APV_CE_RAT_score']})", "")

# --- [P4] 4순위: 고객 불균형 진단 ---
# (분석할 고객층 컬럼만 사용)
age_gender_cols = [col for col in df_customer_profile.columns if 'MAL' in col or 'FME' in col]

# 평균 비중이 5% 미만인 세그먼트가 3개 이상인 경우 (너무 편중됨)
missing_segments_count = (df_analysis[age_gender_cols] < 5.0).sum(axis=1)
df_analysis['P4_Problem'] = (missing_segments_count >= 3)
df_analysis['P4_Details'] = np.where(df_analysis['P4_Problem'], f"고객층 편중(5%미만 {missing_segments_count}개)", "")

print("P1, P2, P3, P4 진단 컬럼 추가 완료.")

# --- 최종 진단 (우선순위 적용) ---
final_cond_list = [
    df_analysis['P1_Problem'] == True,
    df_analysis['P2_Quadrant'].isin(['P2_위기매장', 'P2_숨은맛집', 'P2_박리다매']),
    df_analysis['P3_Problem'] == True,
    df_analysis['P4_Problem'] == True
]

final_choice_list = [
    'P1_매출/고객 급락', # 1순위
    df_analysis['P2_Quadrant'], # 2순위
    'P3_높은 취소율',    # 3순위
    'P4_고객층 불균형'   # 4순위
]

df_analysis['FINAL_DIAGNOSIS'] = np.select(final_cond_list, final_choice_list, default='P0_건강함')

# 진단 세부내용 컬럼
details_cond_list = [
    df_analysis['FINAL_DIAGNOSIS'] == 'P1_매출/고객 급락',
    df_analysis['FINAL_DIAGNOSIS'].isin(['P2_위기매장', 'P2_숨은맛집', 'P2_박리다매']),
    df_analysis['FINAL_DIAGNOSIS'] == 'P3_높은 취소율',
    df_analysis['FINAL_DIAGNOSIS'] == 'P4_고객층 불균형'
]
details_choice_list = [
    df_analysis['P1_Details'],
    df_analysis['P2_Quadrant'] + f"(유치:{acq_score.round(2)}, 수익:{profit_score.round(2)})",
    df_analysis['P3_Details'],
    df_analysis['P4_Details']
]
df_analysis['DIAGNOSIS_DETAILS'] = np.select(details_cond_list, details_choice_list, default='특이 문제 없음')


df_analysis = pd.merge(
    df_analysis,
    df_map[['HPSN_MCT_ZCD_NM', 'map']],
    on='HPSN_MCT_ZCD_NM',
    how='left'
)

# 2. 챗봇용 '진단 차트' 파일 저장 (업데이트된 df_analysis 사용)
output_path_q3 = base_path + 'analysis_problem_diagnosis.csv'
df_analysis.to_csv(output_path_q3, index=False, encoding='utf-8-sig')

print(f"\n--- 3번 질문용 '진단 차트' 파일 저장 완료! (map 컬럼 추가) ---")
print(f"경로: {output_path_q3}") # 이 출력문도 정보를 확인하는 데 유용합니다.
print("\n[최종 진단 결과 샘플 (map 컬럼 포함)]")
print(df_analysis[['MCT_NM', 'FINAL_DIAGNOSIS', 'DIAGNOSIS_DETAILS', 'map']].sample(10))



# --- 챗봇용 '진단 차트' 파일 저장 ---
#output_path_q3 = base_path + 'analysis_problem_diagnosis.csv'
#df_analysis.to_csv(output_path_q3, index=False, encoding='utf-8-sig')

#print(f"\n--- 3번 질문용 '진단 차트' 파일 저장 완료! ---")
#print(f"경로: {output_path_q3}")
#print("\n[최종 진단 결과 샘플]")
#print(df_analysis[['MCT_NM', 'FINAL_DIAGNOSIS', 'DIAGNOSIS_DETAILS']].sample(10))

"""## 4번 질문
탐라 **의 월별 매출을 분석하고 적절한 마케팅 전략을 제시해줘
"""

try:

    # 'ENCODED_MCT' (가맹점 ID) 별로 'TA_YM' (기준년월)의 개수를 셉니다.
    month_counts = df_monthly.groupby('ENCODED_MCT').size()

    # 결과를 DataFrame으로 변환하고 컬럼명을 'MonthCount'로 지정
    month_counts_df = month_counts.reset_index(name='MonthCount')

    # 'MonthCount'가 많은 순서 (내림차순)로 정렬
    month_counts_df_sorted = month_counts_df.sort_values(by='MonthCount', ascending=False)

    # 가맹점 이름('MCT_NM')과 업종('HPSN_MCT_ZCD_NM')을 가져옵니다.
    merged_counts_df = pd.merge(
        month_counts_df_sorted,
        df_info[['ENCODED_MCT', 'MCT_NM', 'HPSN_MCT_ZCD_NM']],
        on='ENCODED_MCT',
        how='left'
    )

    # 상위 20개 가맹점 출력
    print("\n--- [월별 데이터(기준년월)가 가장 많은 가맹점 Top 20] ---")
    print(merged_counts_df.head(60))

    # 전체적인 분포 확인 (최대, 최소, 평균 개수)
    print("\n\n--- [월별 데이터 보유 개수 통계] ---")
    print(merged_counts_df['MonthCount'].describe())

except FileNotFoundError:
    print(f"!!! ❌ 에러: 파일을 찾을 수 없습니다.")
    print(f"경로를 확인하세요. 혹시 'base_path'가 '{base_path}'(이)가 맞나요?")
except Exception as e:
    print(f"!!! ❌ 에러 발생: {e}")

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns

# 분석할 가맹점 ID
TARGET_MCT_ID = 'FEDAD7667E'

try:

    # 가맹점 이름 찾기
    merchant_name_series = df_info[df_info['ENCODED_MCT'] == TARGET_MCT_ID]['MCT_NM']
    if not merchant_name_series.empty:
        merchant_name = merchant_name_series.values[0]
    else:
        merchant_name = TARGET_MCT_ID # 이름을 못찾으면 ID 사용

    print(f"분석 대상: {merchant_name} (ID: {TARGET_MCT_ID})")

    # 해당 가맹점의 월별 데이터 필터링
    df_target = df_monthly[df_monthly['ENCODED_MCT'] == TARGET_MCT_ID].copy()

    if df_target.empty:
        print(f"!!! ❌ 에러: {TARGET_MCT_ID}에 대한 데이터를 찾을 수 없습니다.")
    else:
        # '매출금액 구간'을 숫자 점수로 변환
        # "1_10%이하" -> 1.0, "6_90%초과" -> 6.0
        # 점수가 낮을수록 매출이 '높은' 구간 (상위권)
        df_target['Sales_Score'] = df_target['RC_M1_SAA'].str[0].astype(float)

        # '기준년월'을 시간 순으로 정렬
        # 'TA_YM'을 문자열로 변환하여 x축 레이블로 사용
        df_target['TA_YM_str'] = df_target['TA_YM'].astype(str)
        df_target = df_target.sort_values(by='TA_YM')

        print("\n--- [매출금액 구간 점수 변환 결과 (2023-2024)] ---")
        # 해당 가맹점의 24개월치 데이터를 모두 출력
        print(df_target[['TA_YM_str', 'RC_M1_SAA', 'Sales_Score']].to_string(index=False))

        # 한글 폰트 설정 (시각화를 위해)
        !sudo apt-get install -y fonts-nanum
        !sudo fc-cache -fv
        !rm ~/.cache/matplotlib -rf
        plt.rc('font', family='NanumBarunGothic')
        print("\n(코랩에서 한글 폰트 설정을 실행했다고 가정합니다)")

        plt.rcParams['axes.unicode_minus'] = False # 마이너스 기호 깨짐 방지

        # 시각화 (Line Plot)
        plt.figure(figsize=(15, 7))

        # lineplot 생성
        ax = sns.lineplot(
            data=df_target,
            x='TA_YM_str',
            y='Sales_Score',
            marker='o', # 각 월에 점 표시
            markersize=8
        )

        # 그래프 제목 및 레이블 설정
        plt.title(f"[{merchant_name}] 2년간 매출금액 구간(Rank) 변화 추이", fontsize=18, pad=20)
        plt.xlabel("기준 년월 (TA_YM)", fontsize=12, labelpad=15)
        plt.ylabel("매출금액 구간 점수 (1점 = 상위 10% 이내)", fontsize=12, labelpad=15)

        # x축 레이블 90도 회전 (24개가 겹치므로)
        plt.xticks(rotation=90)

        # Y축 반전: 1점이 '최고'이므로 위로, 6점이 '최하'이므로 아래로 가게 함
        ax.invert_yaxis()

        # y축 눈금을 1, 2, 3, 4, 5, 6 정수로 설정
        plt.yticks([1.0, 2.0, 3.0, 4.0, 5.0, 6.0])

        plt.grid(True, linestyle='--', alpha=0.6) # 그리드 추가
        plt.tight_layout() # 레이아웃 최적화

        # 그래프 파일로 저장
        output_filename = 'sales_trend.png'
        plt.savefig(output_filename)


        print(f"\n그래프가 '{output_filename}' 으로 저장되었습니다.")

        # --- [챗봇 프롬프트 생성을 위한 분석 파트 ] ---

        # (점수(Sales_Score)가 낮을수록(ascending=True) 매출이 높은 것)
        df_sorted_high = df_target.sort_values(by='Sales_Score', ascending=True)
        # .head(3)는 상위 3개를 뽑아냄
        high_months = df_sorted_high['TA_YM_str'].head(3).tolist()

        # (점수(Sales_Score)가 높을수록(ascending=False) 매출이 낮은 것)
        df_sorted_low = df_target.sort_values(by='Sales_Score', ascending=False)
        low_months = df_sorted_low['TA_YM_str'].head(3).tolist()

        print("\n\n--- [챗봇 프롬프트용 분석 결과] ---")
        print(f"매출이 가장 높은 Top 3 월: {high_months}")
        print(f"매출이 가장 낮은 Top 3 월: {low_months}")
        print("--- [분석 완료] ---")

except FileNotFoundError:
    print(f"!!! ❌ 에러: 파일을 찾을 수 없습니다.")
    print(f"경로를 확인하세요. 혹시 'base_path'가 '{base_path}'(이)가 맞나요?")
except Exception as e:
    print(f"!!! ❌ 에러 발생: {e}")

"""## 5번 질문
킴스**이 속한 상권 내에서 같은 업종 매장들과 비교했을 때 현재 순위가 어떻게 되고, 1위를 달성하기 위해 개선하거나 집중해야 할 마케팅 포인트가 무엇인지 분석해줘.
"""

try:
    # 분석에 필요한 파일 2개 로드 (df_info, df_analysis_q3)
    df_info = pd.read_csv(base_path + 'big_data_set1_f.csv', encoding='cp949')
    df_analysis_q3 = pd.read_csv(base_path + 'analysis_problem_diagnosis.csv', encoding='utf-8-sig')
    print("데이터 로드 완료 (df_info, df_analysis_q3)")

    # '임시 분석용' DF 생성 (Q3 마스터 + 상권명 결합)
    df_temp_analysis = pd.merge(
        df_analysis_q3,
        df_info[['ENCODED_MCT', 'HPSN_MCT_BZN_CD_NM']], # '상권명' 컬럼만 가져옴
        on='ENCODED_MCT',
        how='left'
    )

    # (Step 1) 상권이 '뚝섬'인 가게 추출 (정확히 일치)
    seongsu_stores = df_temp_analysis[
        df_temp_analysis['HPSN_MCT_BZN_CD_NM'] == '뚝섬'
    ].copy()
    print(f"\n[Step 1] '뚝섬' 상권 매장 {len(seongsu_stores)}개 추출")

    # (Step 2) 그 중 업종이 '치킨'인 가게 추출 (정확히 일치)
    chicken_stores_in_seongsu = seongsu_stores[
        seongsu_stores['HPSN_MCT_ZCD_NM'] == '치킨' # <-- 수정됨
    ].copy()
    print(f"[Step 2] '치킨' 업종 매장 {len(chicken_stores_in_seongsu)}개 추출")

    # (Step 3) 업종 내 매출 순위 리스트업

    # '업종 내 매출 순위'(M12_SME_RY_SAA_PCE_RT) 기준으로 정렬 (낮을수록 1등)
    df_final_list = chicken_stores_in_seongsu.sort_values(by='M12_SME_RY_SAA_PCE_RT', ascending=True)

    # 결과 출력
    columns_to_show = [
        'MCT_NM',                # 매장 이름
        'HPSN_MCT_BZN_CD_NM',    # 상권명
        'HPSN_MCT_ZCD_NM',       # 업종명
        'M12_SME_RY_SAA_PCE_RT'  # ★업종 내 매출 순위(%)
    ]

    print("\n\n--- [Step 3: '뚝섬' 상권 '치킨' 매장 '업종 내 매출 순위' 리스트] ---")
    if df_final_list.empty:
        print("!!! ❌ 에러: 해당 조건(뚝섬 + 치킨)의 매장을 찾을 수 없습니다.")
    else:
        # .to_string()으로 모든 매장 리스트를 출력
        print(df_final_list[columns_to_show].to_string())

        # (Bonus) '킴스**'의 순위와 1위 매장 찾기
        kims_store = df_final_list[df_final_list['MCT_NM'] == '킴스**']
        first_place_store = df_final_list.iloc[0]

        print("\n\n--- [1위 달성 전략 분석용 근거] ---")
        if not kims_store.empty:
            print(f"킴스**의 현재 '업종 내 순위': {kims_store['M12_SME_RY_SAA_PCE_RT'].values[0]:.1f}%")
        else:
            print("!!! ❌ 경고: '킴스**' 상호명을 리스트에서 찾을 수 없습니다. (상호명 확인 필요)")

        print(f"1위 매장: {first_place_store['MCT_NM']} (순위: {first_place_store['M12_SME_RY_SAA_PCE_RT']:.1f}%)")
        print(f"1위 매장 ID (분석용): {first_place_store['ENCODED_MCT']}")


except FileNotFoundError as e:
    print(f"!!! ❌ 에러: 파일을 찾을 수 없습니다: {e}")
except KeyError as e:
    print(f"!!! ❌ 에러: 컬럼명이 존재하지 않습니다. (예: {e})")
    print("Q3 마스터 파일('analysis_problem_diagnosis.csv')이 올바르게 생성되었는지 확인하세요.")
except Exception as e:
    print(f"!!! ❌ 에러 발생: {e}")

import streamlit as st
import pandas as pd
import numpy as np

# --- 데이터 로딩 (앱 실행 시 1번만 실행) ---
@st.cache_data
def load_data():
    """
    분석에 필요한 2개의 마스터 파일을 로드하고, '상권명'을 결합한
    최종 분석용 데이터프레임을 반환합니다.
    """
    try:
        df_info = pd.read_csv('big_data_set1_f.csv', encoding='cp949')
        df_analysis_q3 = pd.read_csv('analysis_problem_diagnosis.csv', encoding='utf-8-sig')

        # '임시 분석용' DF 생성 (Q3 마스터 + 상권명 결합)
        df_merged = pd.merge(
            df_analysis_q3,
            df_info[['ENCODED_MCT', 'HPSN_MCT_BZN_CD_NM']],
            on='ENCODED_MCT',
            how='left'
        )
        return df_merged
    except FileNotFoundError:
        st.error("데이터 파일을 찾을 수 없습니다. 'big_data_set1_f.csv'와 'analysis_problem_diagnosis.csv' 파일이 있는지 확인하세요.")
        return None

# --- 핵심 분석 함수 ---
def analyze_competitors(df, store_name):
    """
    전체 데이터프레임과 특정 가게 이름을 입력받아,
    같은 상권/업종 내 순위 리스트와 주요 정보를 반환합니다.
    """
    if df is None or store_name is None:
        return "데이터 로딩 실패", None, None

    # 1. 입력받은 가게의 '상권'과 '업종' 정보 조회
    target_store_info = df[df['MCT_NM'] == store_name]
    if target_store_info.empty:
        return f"분석 대상인 '{store_name}' 정보를 데이터에서 찾을 수 없습니다.", None, None

    target_bzn = target_store_info['HPSN_MCT_BZN_CD_NM'].iloc[0]
    target_zcd = target_store_info['HPSN_MCT_ZCD_NM'].iloc[0]

    if pd.isna(target_bzn) or pd.isna(target_zcd):
        return f"'{store_name}'의 상권 또는 업종 정보가 명확하지 않아 비교 분석을 할 수 없습니다.", None, None

    # 2. 같은 상권 & 같은 업종 가게 추출
    competitor_df = df[
        (df['HPSN_MCT_BZN_CD_NM'] == target_bzn) &
        (df['HPSN_MCT_ZCD_NM'] == target_zcd)
    ].copy()

    # 3. '업종 내 매출 순위' 기준으로 정렬하여 순위 부여
    df_final_list = competitor_df.sort_values(by='M12_SME_RY_SAA_PCE_RT', ascending=True).copy()
    df_final_list['Rank'] = range(1, len(df_final_list) + 1)

    # 4. 분석 결과 추출
    my_store_rank_info = df_final_list[df_final_list['MCT_NM'] == store_name]
    first_place_store_info = df_final_list.iloc[0]

    return df_final_list, my_store_rank_info, first_place_store_info

# --- LLM 프롬프트 생성 함수 ---
def create_llm_prompt(my_rank, first_place):
    """'내 가게'와 '1위 가게' 정보를 받아 LLM 프롬프트를 생성합니다."""

    # (고객 프로필 컬럼만 추출하여 비교)
    customer_cols = [col for col in my_rank.index if 'RAT' in col and ('MAL' in col or 'FME' in col)]
    my_profile = my_rank[customer_cols]
    first_profile = first_place[customer_cols]

    # 두 프로필 간의 차이(격차) 계산
    gap = first_profile - my_profile

    # 가장 큰 격차(Gap)를 보이는 고객층 찾기
    biggest_gap_col = gap.idxmax()
    biggest_gap_value = gap.max()

    # 컬럼명을 한글로 변환 (예시)
    col_to_korean = { 'M12_FME_30_RAT': '30대 여성 고객 비중' } # (실제로는 전체 딕셔너리 필요)
    gap_label = col_to_korean.get(biggest_gap_col, biggest_gap_col)

    prompt = f"""
당신은 마케팅 AI '비밀상담사'입니다.
'킴스**'가 1위를 달성하기 위한 전략을 제안해야 합니다.

[데이터 분석 근거]
- 가맹점명: {my_rank['MCT_NM']}
- 현재 상권 내 순위: {my_rank['Rank']}위 (업종 내 매출 순위: {my_rank['M12_SME_RY_SAA_PCE_RT']:.1f}%)

[1위 매장 '{first_place['MCT_NM']}' 비교 분석]
- 1위 매장 순위: 1위 (업종 내 매출 순위: {first_place['M12_SME_RY_SAA_PCE_RT']:.1f}%)
- **[핵심 격차]**: 1위 매장은 '{gap_label}'이 {first_place[biggest_gap_col]:.1f}%인데 반해,
  '킴스**'는 {my_rank[biggest_gap_col]:.1f}%로, {biggest_gap_value:.1f}%p의 큰 격차를 보입니다.

[요청 사항]
1. 위 [핵심 격차]를 바탕으로, '킴스**'가 1위를 달성하기 위해
2. '{gap_label}'을 집중 공략할 수 있는 마케팅 포인트 2가지를 제안해주세요.
3. (우리 컨셉) **'선선한 가을 저녁'** 시즌성을 함께 고려하여 제안해주세요.
"""
    return prompt

# --- Streamlit UI 구성 ---
st.title("📈 '킴스**' 경쟁사 비교 분석")

# 1. 데이터 로드
df_merged = load_data()

if df_merged is not None:
    # 2. '킴스**'에 대한 분석 바로 실행
    error_msg, rank_df, my_rank, first_place = None, None, None, None
    with st.spinner("'킴스**'의 경쟁 환경을 분석 중입니다..."):
        error_msg, rank_df, my_rank, first_place = analyze_competitors(df_merged, "킴스**")

    if error_msg:
        st.error(error_msg)
    else:
        st.success("분석이 완료되었습니다!")

        my_bzn = my_rank['HPSN_MCT_BZN_CD_NM'].iloc[0]
        my_zcd = my_rank['HPSN_MCT_ZCD_NM'].iloc[0]

        st.subheader(f"📍 '{my_bzn}' 상권 내 '{my_zcd}' 업종 순위")

        # 3. 분석 결과 표 출력
        columns_to_show = ['Rank', 'MCT_NM', 'M12_SME_RY_SAA_PCE_RT']
        st.dataframe(rank_df[columns_to_show].rename(columns={
            'Rank': '순위', 'MCT_NM': '가게 이름', 'M12_SME_RY_SAA_PCE_RT': '업종 내 매출 순위(%)'
        }))

        # 4. LLM 프롬프트 생성 및 (가상) 답변 출력
        st.subheader("💡 1위 달성을 위한 마케팅 전략")

        prompt_for_llm = create_llm_prompt(my_rank.squeeze(), first_place.squeeze())

        # (실제 챗봇에서는 이 프롬프트를 Gemini API로 전송)
        st.code(prompt_for_llm, language='markdown') # (디버깅용: 생성된 프롬프트 확인)

        # (LLM 답변 예시 출력)
        st.markdown("""
        ---
        #### **AI 제안:** 1위 달성을 위해 **'30대 여성'** 고객을 공략하세요!

        **[제안 1] '가을밤 치맥' 감성 마케팅 (온라인)**
        * 30대 여성이 활발한 **'인스타그램'**을 공략합니다. '가을밤', '성수동', '테라스' 키워드를 활용한 감성적인 매장 사진을 포스팅하세요.
        * **[홍보 문구 예시]** "선선한 가을밤, 성수동 테라스에서 치맥 어때요? 🍂 지금 킴스**에서 '로제 치킨' 신메뉴 주문 시, 하이볼 1잔 무료! #성수동맛집 #성수치킨 #가을밤 #치맥"

        **[제안 2] '30대 여성' 타겟 메뉴 개발 (오프라인)**
        * 기존 메뉴 외에 30대 여성이 선호하는 '로제', '바질', '콘치즈' 등을 활용한 신메뉴를 개발하여 '1위 매장'의 고객을 끌어와야 합니다.
        * **[실행 방안]** '로제 떡볶이 치킨 세트' 또는 '바질 치킨 + 하이볼 2잔' 세트 메뉴를 구성하여 객단가와 만족도를 동시에 높이는 전략을 추천합니다.
        """)